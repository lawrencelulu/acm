/*
有一个n*m格的迷宫(表示有n行、m列)，其中有可走的也有不可走的，如果用1表示可以走，0表示不可以走，文件读入这n*m个数据和起始点、结束点(起始点和结束点都是用两个数据来描述的，分别表示这个点的行号和列号)。现在要你编程找出所有可行的道路，要求所走的路中没有重复的点，走时只能是上下左右四个方向。如果一条路都不可行，则输出相应信息(用-l表示无路)。
　　请统一用 左上右下的顺序拓展，也就是 (0,-1),(-1,0),(0,1),(1,0)
输入
第一行是两个数n，m( 1 < n ， m < 15 )，接下来是m行n列由1和0组成的数据，最后两行是起始点和结束点。

输出
　　所有可行的路径，描述一个点时用(x，y)的形式，除开始点外，其他的都要用“->”表示方向。
　　如果没有一条可行的路则输出-1。

样例输入 Copy
5 6
1 0 0 1 0 1
1 1 1 1 1 1
0 0 1 1 1 0
1 1 1 1 1 0
1 1 1 0 1 1
1 1
5 6
样例输出 Copy
(1,1)->(2,1)->(2,2)->(2,3)->(2,4)->(2,5)->(3,5)->(3,4)->(3,3)->(4,3)->(4,4)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(2,4)->(2,5)->(3,5)->(3,4)->(4,4)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(2,4)->(2,5)->(3,5)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(2,4)->(3,4)->(3,3)->(4,3)->(4,4)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(2,4)->(3,4)->(3,5)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(2,4)->(3,4)->(4,4)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(3,3)->(3,4)->(2,4)->(2,5)->(3,5)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(3,3)->(3,4)->(3,5)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(3,3)->(3,4)->(4,4)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(3,3)->(4,3)->(4,4)->(3,4)->(2,4)->(2,5)->(3,5)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(3,3)->(4,3)->(4,4)->(3,4)->(3,5)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(3,3)->(4,3)->(4,4)->(4,5)->(5,5)->(5,6)
*/

#include <stdio.h>
const int maxn = 50;
int p, q, n, m;
int a[maxn][maxn], book[maxn][maxn];
int next[4][2]= {{0,-1},{-1,0},{0,1},{1,0}};
bool has_no_result=true;
struct point {
    int x;
    int y;
} P[500];
void dfs(int x, int y, int num){
    int tx, ty;
    if(x == p && y == q){
        for(int i = 0; i < num; i++)
            printf("(%d, %d)->", P[i].x, P[i].y);
        printf("(%d, %d)\n", x, y);
        has_no_result = false;
        return;
    }

    P[num].x = x;
    P[num].y = y;
    for(int k = 0; k < 4; k++){
        tx = x + next[k][0];
        ty = y + next[k][1];

        if(tx<1||tx>n||ty<0||ty>m)
            continue;
        if(a[tx][ty] == 1 && book[tx][ty] == 0)
        {
            book[tx][ty] = 1;
            dfs(tx, ty, num+1);
            book[tx][ty] = 0;
        }
    }
    return;

};

int main()
{
//    freopen("input.txt", "r", stdin);
    int startx, starty;
    scanf("%d%d", &n, &m);
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++)
            scanf("%d", &a[i][j]);

    scanf("%d%d%d%d", &startx, &starty, &p, &q);
    book[startx][starty] = 1;
    dfs(startx, starty, 0);
    if(has_no_result)
        printf("-1\n");
    return 0;
}
